#+TITLE:open soft restricted data 
#+AUTHOR: Ivan Hanigan
#+email: ivan.hanigan@anu.edu.au
#+LaTeX_CLASS: article
#+LaTeX_CLASS_OPTIONS: [a4paper]
#+LATEX: \tableofcontents
-----

* INIT
** COMMENT init
#+name:init
#+begin_src R :session *shell* :tangle no :exports none :eval yes
  #### name:init ####
  projdir  <- "~/projects/opensoftware-restricteddata.github.com/report1_high_level"
  setwd(projdir)
  dir()
  
  
#+end_src

#+RESULTS: init
| A1BDRY_RainSD07.jpg    |
| A1BWET_RainSD07.jpg    |
| code                   |
| components             |
| data                   |
| Figure1.png            |
| index.org              |
| manuscript_files       |
| manuscript.pdf         |
| manuscript.Rmd         |
| manuscript.Rmd~        |
| manuscript.tex         |
| meemodified.csl        |
| opensoft.pdf           |
| opensoft_workflow.xlsx |
| references.bib         |

* exposure
*** TODO just get the preprocessed drought_futures from garnaut
#+begin_src R :session *shell* :tangle no :exports none :eval no
  qc <- read.csv("~/projects/GARNAUT_CLIMATE_CHANGE_REVIEW/drought_futures/data/drought_future_estimated_dry.csv")
  sd_i <- "Central West"
  str(qc)
  qc$date <- as.Date(qc$date)
  dir()
  qc2 <- qc[qc$sd_group == sd_i,]
  png("graphs/qc_drought_count_central_west.png", width = 1200, height = 600)
  with(qc2,
       plot(date, count, type = "l")
       )
  dev.off()
  # perhaps let's exclude years > 2090 as too the uncertain?
  drt <- qc[qc$year > 2008,]
  qc[qc$year == 1900 & qc$month == 1,]
  
  
  qc <- read.csv("~/projects/GARNAUT_CLIMATE_CHANGE_REVIEW/drought_futures/data/drought_future_estimated_wet.csv")
  sd_i <- "Central West"
  str(qc)
  qc$date <- as.Date(qc$date)
  dir()
  qc2 <- qc[qc$sd_group == sd_i,]
  png("graphs/qc_drought_count_central_west_wet.png", width = 1200, height = 600)
  with(qc2,
       plot(date, count, type = "l")
       )
  dev.off()
  
  drt_wet <- qc[qc$year > 2008,]
  
#+end_src

*** TODO DEPRECATED BoM awap is improved historical, but took too long to do zonal stats per SD
#+name:or use awap grids and csiro access
#+begin_src R :session *shell* :tangle code/awap_grids_on_nswsd.R :exports none :eval no
  #### name:or use awap grids and csiro access ####
  require(swishdbtools)
  if(!require(raster)) install.packages("raster", dependencies = T); require(raster)
  if(!require(rgdal)) install.packages("rgdal", dependencies = T); require(rgdal)
  library(sqldf)  
  
  
  projdir <- "~/projects/opensoftware-restricteddata.github.com/report1_high_level"
  setwd(projdir)
  dir()
  outfile <- "awap_rain_nswsd07.csv"
  
  # load the spatial data for nsw sds
  #args(readOGR2)
  pwd <- getPassword(remote = T)
  shp <- readOGR2(hostip = "gislibrary.anu.edu.au", user = "gislibrary", db = "gislibrary", layer = "abs_sd.aussd07", p = pwd)
  
  #shp <- readOGR2(hostip = "localhost", user = "ivan_hanigan", db = "postgis_hanigan", layer = "abs_sd.aussd07", p = pwd)
  head(shp@data)
  shp <- shp[shp@data$state07==1,]
  writeOGR(shp, "data", "nswsd07", driver = "ESRI Shapefile")
  
  png("graphs/qc_sdmap.png")
  plot(shp)
  dev.off()
  shp@data
  
  # now climate data
  
  indir <- "~/ResearchData/AWAP_GRIDS/AWAP_GRIDS_RAIN_MONTHLY"
  #dir(indir)
  
  setwd(indir)
  cfiles <-  dir(pattern="tif$")
  cfiles[1:10]
  tail(cfiles)
  for(i in seq_len(length(cfiles))){
    #i <- 1 ## for stepping thru
    gridname <- cfiles[[i]]
    r <- raster(gridname)
    e <- extract(r, shp, df=T, fun = mean)
    e1 <- shp
    e1@data$values <- e[,2]
    e1@data$gridname <- gridname
    # e1@data
    # write to to target file
    write.table(e1@data, file.path(projdir,"data", outfile),
      col.names = i == 1, append = i>1 , sep = ",", row.names = FALSE)
  }
  setwd(projdir)
  dat <- read.csv(file.path("data",outfile))
  names(dat)
  names(table(dat$gridname))
  qc_foo <- qc[qc$year == 1900 & qc$month == 1,]
  qc_foo2 <- dat[grep("190001", dat$gridname),]
  with(merge(qc_foo, qc_foo2, by.x = "sd_group", by.y = "sdname07")[,c("sd_group", "avrain", "values")],
       plot(avrain, values)
       )
#+end_src

*** TODO CSIRO ACCESS is improved future
#+name:CSIRO ACCESS is improved future
#+begin_src R :session *shell* :tangle code/csiro_access_nswsd_future.R :exports none :eval no
  #### name:CSIRO ACCESS is improved future ####
  # see 'climate change csiro access'
  library(swishdbtools)
  library(raster)
  library(rgdal)
  library(sqldf)  
  library(ncdf4)
  
  projdir <- "~/projects/opensoftware-restricteddata.github.com/report1_high_level"
  setwd(projdir)
  dir()
  outfile <- "csiro_rain_nswsd07.csv"
  
  # load the spatial data for nsw sds
  #args(readOGR2)
  #get_passwordTable()
  ## pwd <- getPassword(remote = T)
  ## shp <- readOGR2(hostip = "gislibrary.anu.edu.au", user = "gislibrary", db = "gislibrary", layer = "abs_sd.aussd07", p = pwd)
  
  ## #shp <- readOGR2(hostip = "localhost", user = "ivan_hanigan", db = "postgis_hanigan", layer = "abs_sd.aussd07", p = pwd)
  ## head(shp@data)
  ## shp <- shp[shp@data$state07==1,]
  ## writeOGR(shp, "data", "nswsd07", driver = "ESRI Shapefile")
  
  shp <- readOGR("data", "nswsd07")
  # TODO subset so island is gone
  png("graphs/qc_sdmap.png")
  plot(shp)
  dev.off()
  shp@data
  
  # now climate data
  
  indir <- "~/ResearchData/CSIRO-ACCESS-NSW-past-and-future-2100/data_provided"
  dir(indir)
  ## [1] "NSW_pr_Amon_ACCESS1-3_historical_r1i1p1_185001-200512.nc"
  ## [2] "NSW_pr_Amon_ACCESS1-3_rcp85_r1i1p1_200601-210012.nc"     
  
  setwd(indir)
  
  dir(indir)
  infile <- "NSW_pr_Amon_ACCESS1-3_historical_r1i1p1_185001-200512.nc"
  in_nc <- file.path(indir, infile)
  
  nc <- nc_open(in_nc)
  nc
  nc_close(nc)
      ##  3 dimensions:
      ##     longitude  Size:9
      ##         units: degrees_east
      ##         long_name: longitude
      ##     latitude  Size:8
      ##         units: degrees_north
      ##         long_name: latitude
      ##     value  Size:1872   *** is unlimited ***
      ##         units: unknown
      ##         long_name: value
  
      ## 3 global attributes:
      ##     Conventions: CF-1.4
      ##     created_by: R, packages ncdf and raster (version 2.3-12)
      ##     date: 2015-11-10 11:04:37
  
  
  in_nc
  yy  <- data.frame(yy = 1850:2005)
  mm  <-  data.frame(mm= 1:12)
  mnths <- sqldf("select * from yy join mm order by yy, mm")
  nrow(mnths)
  # 1872
  head(mnths, 24)
  
  for(i in 1:1872){
  #  i = 1
    r <- raster(in_nc, band = i)  
    gridname <- paste(mnths[i,1],mnths[i,2], 1, sep = "-")
  #print(gridname)
  #}
    e <- extract(r, shp, df=T, fun = mean)
  ## Warning message:
  ## In .local(x, y, ...) :
  ##   Transforming SpatialPolygons to the CRS of the Raster
  ## shp is   ..@ proj4string:Formal class 'CRS' [package "sp"] with 1 slot
  ## .. .. ..@ projargs: chr "+proj=longlat +ellps=GRS80 +no_defs"
  ## r is   ..@ crs     :Formal class 'CRS' [package "sp"] with 1 slot
  ##.. .. ..@ projargs: chr "+proj=longlat +datum=WGS84 +ellps=WGS84 +towgs84=0,0,0"
    
    e1 <- shp@data
    e1$values <- e[,2]
    e1$gridname <- gridname
    # e1
    # NOTE THAT MID NORTH COAST IS NA
    # write to to target file
    write.table(e1,
                file.path(projdir,"data", outfile),
                col.names = i == 1, append = i>1 , sep = ",", row.names = FALSE
                )
  }
  getwd()
  setwd(projdir)
  dat <- read.csv(file.path("data",outfile))
  names(dat)
  dat$gridname <- as.Date(dat$gridname)
  dat$year <- as.numeric(substr(dat$gridname ,1, 4))
  dat$month <- as.numeric(substr(dat$gridname ,6, 7))
  #names(table(dat$gridname))
  str(dat)
  
  str(qc)
  qc_foo <- qc[qc$year >= 1900,]
  qc_foo2 <- dat[dat$year >= 1900,]
  qc_foo3  <- merge(qc_foo, qc_foo2, by.x = c("sd_group", "year", "month"), by.y = c("sdname07", "year" , "month"))[,c("sd_group", "year", "month", "avrain", "values")]
  head(qc_foo3)
  png("graphs/qc_csiro_vs_bom_grids.png")
  with(qc_foo3,
        plot(avrain, values)
        )
  title("qc csiro vs bomgrids 1900-2005")
  dev.off()
  
#+end_src

* baseline outcome
*** COMMENT baseline_outcome
#+begin_src R :session *shell* :tangle no :exports none :eval no
  #### name:baseline_outcome ####
  require(swishdbtools) # get from http://swish-climate-impact-assessment.github.io/tools/swishdbtools/swishdbtools-downloads.html
  ch <- connect2postgres2("delphe")
  data <- dbGetQuery(ch,
  "
  select cast(dthyy || '-' || dthmm || '-' || 1 as date) as time, *
  from ivan_hanigan.suicidedroughtnsw19702007_rates_drought
  ")
  str(data)
  data.frame(table(data$sd_group))
  ##                     Var1 Freq
  ## 1           Central West 6356
  ## 2                 Hunter 6356
  ## 3              Illawarra 6356
  ## 4        Mid-North Coast 6356
  ## 5                 Murray 6356
  ## 6           Murrumbidgee 6356
  ## 7  North and Far Western 6356
  ## 8               Northern 6356
  ## 9         Richmond-Tweed 6356
  ## 10         South Eastern 6356
  ## 11                Sydney 6356
  
#+end_src

* predicted attributable in future
*** clean_set_datatypes.R
#+begin_src R :session *shell* :tangle code/clean_set_datatypes.R :exports none :eval no
  #### name:fit_baseline_model ####
  # create a drought variable for each category
  # ie pre-calculated Drought by Age, Sex and Rural/Urban Region terms, constructed to have the value of the drought index in the specified groups (with Ages grouped by 20 year age brackets) and zero otherwise.
  # NOTE that we initially fitted this model with a drought effect in each 10 year age bracket, however the 20 year age brackets give essentially the same results, and is simpler to calculate.
    
  require(mgcv)
  require(splines)
  
  # Log transform drought variable, see data preparation for that diagnostic
  data$logDroughtCount = log1p(data$avcount)
  
  # set up the formats of these variables
  data$time=as.Date(paste(data$dthyy,data$dthmm,1,sep='-'))
  data$dthmm=as.factor(data$dthmm)
  data$mm=as.numeric(data$dthmm)
  
  # set up timevar for sinusoidal want
  timevar <- as.data.frame(names(table(data$time)))
  index <- 1:length(names(table(data$time)))
  timevar$time2 <- index/ (length(index) / (length(index)/12))
  names(timevar) <- c('time','timevar')
  timevar$time <- as.Date(timevar$time)
  data <- merge(data,timevar)
  data$time <- as.numeric(data$time)
  data$agegp <- as.factor(data$agegp)
  data$sd_group <- as.factor(data$sd_group)
  str(data)
  
  
  data$rural <-ifelse(data$sd_group %in% c('Central West','Mid-North Coast','Murray','Murrumbidgee','North and Far Western','Northern','Richmond-Tweed','South Eastern'), 1, 0)
    
  data$agegp2 <-ifelse(data$agegp %in% c('10_19','20_29'), '10_29',
  ifelse(data$agegp %in% c('30_39','40_49'), '30_49',
  ifelse(data$agegp %in% c('50_59','60_69','70plus'), '50plus',
  0)))
    
  data$agegp2 <- as.factor(data$agegp2)
    
  ages <- c('10_19','20_29','30_39','40_49','50_59','60_69','70plus')
  ages2 <- c('10_29','30_49','50plus')
    
  # step thru each
  ## for(sexs in 1:2){
  ## # sexs <- c(2)#,2)
  ## if(sexs == 1) {sexid <- 'Males'} else {sexid <- 'Females'}
  ## #sexid <- c('Females')#,'Females')
  ## for(rural in 0:1){
  ## # rural <- c(1)#,0)
  ## if(rural == 0) {ruralid <- c('urban')} else {ruralid<-'rural'} #,'urban')
    
  ## cat(
  ## paste(
  ## 'data$Drt',sexid,ages2,ruralid,' <- ifelse(data$agegp2 == ',ages2,' & data$sex == ',sexs,' & data$rural == ',rural,', data$logDroughtCount, 0)',
  ## collapse = '
  ## ',sep='')
  ## )
  ## cat('
    
  ## ')
  ## }
    
  ## }
    
  # need to add ' to each agegp
  data$DrtMales10_29urban <- ifelse(data$agegp2 == '10_29' & data$sex == 1 & data$rural == 0, data$logDroughtCount, 0)
  data$DrtMales30_49urban <- ifelse(data$agegp2 == '30_49' & data$sex == 1 & data$rural == 0, data$logDroughtCount, 0)
  data$DrtMales50plusurban <- ifelse(data$agegp2 == '50plus' & data$sex == 1 & data$rural == 0, data$logDroughtCount, 0)
    
  data$DrtMales10_29rural <- ifelse(data$agegp2 == '10_29' & data$sex == 1 & data$rural == 1, data$logDroughtCount, 0)
  data$DrtMales30_49rural <- ifelse(data$agegp2 == '30_49' & data$sex == 1 & data$rural == 1, data$logDroughtCount, 0)
  data$DrtMales50plusrural <- ifelse(data$agegp2 == '50plus' & data$sex == 1 & data$rural == 1, data$logDroughtCount, 0)
    
  data$DrtFemales10_29urban <- ifelse(data$agegp2 == '10_29' & data$sex == 2 & data$rural == 0, data$logDroughtCount, 0)
  data$DrtFemales30_49urban <- ifelse(data$agegp2 == '30_49' & data$sex == 2 & data$rural == 0, data$logDroughtCount, 0)
  data$DrtFemales50plusurban <- ifelse(data$agegp2 == '50plus' & data$sex == 2 & data$rural == 0, data$logDroughtCount, 0)
    
  data$DrtFemales10_29rural <- ifelse(data$agegp2 == '10_29' & data$sex == 2 & data$rural == 1, data$logDroughtCount, 0)
  data$DrtFemales30_49rural <- ifelse(data$agegp2 == '30_49' & data$sex == 2 & data$rural == 1, data$logDroughtCount, 0)
  data$DrtFemales50plusrural <- ifelse(data$agegp2 == '50plus' & data$sex == 2 & data$rural == 1, data$logDroughtCount, 0)
#+end_src
*** fit_baseline_model
#+begin_src R :session *shell* :tangle code/do_fit_model.R :exports none :eval no
    
  ######################
  #do,  The final drought model estimates by age, sex and region
  ######################
  # fit the GLM with recommended df
  strt=Sys.time()
  interactionDrtAgeSexRuralModel3 <- glm(deaths ~ sin(timevar*2*pi) + cos(timevar*2*pi)
  + tmax_anomaly
  + DrtMales10_29rural
  + DrtMales30_49rural
  + DrtMales50plusrural
  + DrtFemales10_29rural
  + DrtFemales30_49rural
  + ns(DrtFemales50plusrural, df = 5)
  + ns(DrtMales10_29urban, df = 6)
  + DrtMales30_49urban
  + ns(DrtMales50plusurban, df = 4)
  + DrtFemales10_29urban
  + ns(DrtFemales30_49urban, df = 3)
  + DrtFemales50plusurban
  + agegp2
  + rural
  + sd_group
  + sex
  + agegp
  + agegp*sex*ns(time,3)
  + offset(log(pop)), data=data,family=poisson)
  #save.image()
  endd=Sys.time()
  print(endd-strt)
  
  summary(interactionDrtAgeSexRuralModel3)
  #Rsquared.glm.gsm(interactionDrtAgeSexRuralModel3)
  
  
  
#+end_src

*** predict_attributable_future
#+name:predict_attributable_future
#+begin_src R :session *shell* :tangle no :exports none :eval no
  #### name:predict_attributable_future ####
  # DEPRECATED drt <- read.csv("data/drought_future_estimated_dry.csv", stringsAsFactors = F)
  # newnode get estimate as attributable deaths
  # need to calculate
  # y(attributableToX) = sum((y0 x (exp(beta * X) - 1) x Pop))
  # where y0 is the baseline incidence rate for the health endpoint being quantified;
  # Pop is the population affected and
  # beta is the effect coefficient drawn from the model.
    
    
  # get a test dataset
  
  paste(names(data)[c(2:9,17)],sep='', collapse="','")
  data2 <- data[,c('sd_group','rural','sex','agegp','agegp2','dthyy', 'dthmm','deaths','pop','logDroughtCount')]
  head(data2)
  # use the average rates deaths/person/month
  # newnode get descriptive deaths by age/sex/month/zone groups
  # calculate baseline incidence
    
  names(data)
  desc <- sqldf('
  select sd_group, sex, agegp,avg(deaths) as avgMonthlyDeaths, avg(pop) as avgPop,
  avg(deaths)/avg(pop) as avgRate
  from data
  group by sd_group, sex, agegp
  order by sd_group, sex, agegp
  ', drv = "SQLite")
  head(desc)
  desc[1:40,]
  sqldf(
  'select sd_group, sum(avgMonthlyDeaths), sum(avgPop)
  from desc
  group by sd_group
  order by sd_group
  ', drv = "SQLite")
  subset(desc, sd_group == 'Sydney')
  ## with(subset(data, sd_group == 'Sydney' & sex == 1), plot(agegp,deaths/pop))
  ## with(subset(data, sd_group == 'Sydney' & sex == 1 & agegp == '70plus'),
  ## plot(as.Date(paste(dthyy, dthmm, 1, sep='-')), deaths, type = 'l', col = 'grey')
  ## )
  ## abline(2.3392070,0)
  ## dev.off()
  # ok merge with the test dataset
  str(desc)
  data2 <- merge(data2, desc, by =  c('sd_group', 'sex', 'agegp'))
  subset(desc, sd_group == 'Central West')
  head(data2)
#+end_src
*** COMMENT dry
#+name:dry
#+begin_src R :session *shell* :tangle no :exports none :eval no
   #### name:dry ####



    
  #### Add the future drought estimates (log)
  str(data2)
  str(drt)
  drt$logDroughtCount_future <- log1p(drt$count)
  
  
  # now use the coefficient in
  # y(attributable) = baselineIncidence x (exp(beta * X) - 1) x Pop
  # recall I used
  glmest<-summary(interactionDrtAgeSexRuralModel3)$coefficients
  betai <- glmest[which(row.names(glmest)=='DrtMales30_49rural'),1]
  sei <- glmest[which(row.names(glmest)=='DrtMales30_49rural'),2]
  # estimate only for  DrtMales30_49rural
  attributable <- subset(data2, rural == 1 & sex ==1 & agegp2 == '30_49')
  table(attributable$sd_group)
  str(attributable)
  
  # previous work used the monthly observed incidence
  # for this work I will use the avg incidnce (and pop) over the 38
  # years
  # subset to rural, add age2
  desc$rural <-ifelse(desc$sd_group %in% c('Central West','Mid-North Coast','Murray','Murrumbidgee','North and Far Western','Northern','Richmond-Tweed','South Eastern'), 1, 0)
  desc$agegp2 <-ifelse(desc$agegp %in% c('10_19','20_29'), '10_29',
  ifelse(desc$agegp %in% c('30_39','40_49'), '30_49',
  ifelse(desc$agegp %in% c('50_59','60_69','70plus'), '50plus',
  0)))
    
  desc$agegp2 <- as.factor(desc$agegp2)
  
  attributable2 <- subset(desc, rural == 1 & sex ==1 & agegp2 == '30_49')
  table(attributable2$sd_group)
  str(attributable2)
  attributable2
  str(drt)
  drt$sd_group <- as.factor(drt$sd_group)
  attributable2 <- merge(drt, attributable2, by = "sd_group")
  str(attributable2)
  attach(attributable2)
    
  attributable2$deathsAttributable <-
  (avgMonthlyDeaths/avgPop) * (exp(betai * logDroughtCount_future) - 1) * avgPop
  # SE
  #LCI
  attributable2$deathsAttributableLower <-
  (avgMonthlyDeaths/avgPop) * (exp((betai - sei * 1.96) *  logDroughtCount_future) - 1) * avgPop
  #UCI
  attributable2$deathsAttributableUpper <-
  (avgMonthlyDeaths/avgPop) * (exp((betai + sei * 1.96) * logDroughtCount_future) - 1) * avgPop
    
  detach(attributable2)
  head(attributable2)
    
    
  # now summarise by year
  summaryAttributable <- sqldf(
  'select year, sum(deathsAttributable) as deathsAttributable
  from attributable2
  group by year
  order by year
  ', drv = "SQLite")
  summaryAttributable
  # plot the estimated deaths
  ## with(summaryAttributable,
  ## plot(dthyy, deathsAttributable/deaths, type = 'l')
  ## )
  ## par(new=T)
  ## with(summaryAttributable,
  ## plot(dthyy, logDroughtCount, type = 'l',col = 'blue')
  ## )
  ## par(new=T)
  ## with(summaryAttributable,
  ## plot(dthyy, deaths, type = 'b',col = 'darkblue', pch=16)
  ## )
  # calcualte estimate
    
  estOut <- sqldf(
  'select 
  sum(deathsAttributable) as deathsAttributable,
  sum(deathsAttributableLower) as deathsAttributableLower,
  sum(deathsAttributableUpper) as deathsAttributableUpper
  from attributable2
  ', drv = "SQLite")
    
  # The predicted number of rural male suicides aged 30-49 per annum associated with droughts over our study period was 4.01 (95%CI 2.14 to 6.05)
  estOut$deathsAttributable
  length(names(table(attributable2$year)))
  estOut$deathsAttributable / 92
  estOut$deathsAttributableLower / 92
  estOut$deathsAttributableUpper / 92
    
  # DRY scenario given all years 2009-2100 droughts
  ## > estOut$deathsAttributable
  ## [1] 819.4857
  ## > length(names(table(attributable2$year)))
  ## [1] 92
  ## > estOut$deathsAttributable / 92
  ## [1] 8.907453
  ## >  estOut$deathsAttributableLower / 92
  ## [1] 4.563259
  ## >  estOut$deathsAttributableUpper / 92
  ## [1] 14.00149
   
  
#+end_src
*** COMMENT wet
#+name:dry
#+begin_src R :session *shell* :tangle no :exports none :eval no
  
    
  #### Add the future drought estimates (log)
  str(data2)
  str(drt_wet)
  drt <- drt_wet
  drt$logDroughtCount_future <- log1p(drt$count)
  
  
  # now use the coefficient in
  # y(attributable) = baselineIncidence x (exp(beta * X) - 1) x Pop
  # recall I used
  glmest<-summary(interactionDrtAgeSexRuralModel3)$coefficients
  betai <- glmest[which(row.names(glmest)=='DrtMales30_49rural'),1]
  sei <- glmest[which(row.names(glmest)=='DrtMales30_49rural'),2]
  # estimate only for  DrtMales30_49rural
  attributable <- subset(data2, rural == 1 & sex ==1 & agegp2 == '30_49')
  table(attributable$sd_group)
  str(attributable)
  
  # previous work used the monthly observed incidence
  # for this work I will use the avg incidnce (and pop) over the 38
  # years
  # subset to rural, add age2
  desc$rural <-ifelse(desc$sd_group %in% c('Central West','Mid-North Coast','Murray','Murrumbidgee','North and Far Western','Northern','Richmond-Tweed','South Eastern'), 1, 0)
  desc$agegp2 <-ifelse(desc$agegp %in% c('10_19','20_29'), '10_29',
  ifelse(desc$agegp %in% c('30_39','40_49'), '30_49',
  ifelse(desc$agegp %in% c('50_59','60_69','70plus'), '50plus',
  0)))
    
  desc$agegp2 <- as.factor(desc$agegp2)
  
  attributable2 <- subset(desc, rural == 1 & sex ==1 & agegp2 == '30_49')
  table(attributable2$sd_group)
  str(attributable2)
  attributable2
  str(drt)
  drt$sd_group <- as.factor(drt$sd_group)
  attributable2 <- merge(drt, attributable2, by = "sd_group")
  str(attributable2)
  attach(attributable2)
    
  attributable2$deathsAttributable <-
  (avgMonthlyDeaths/avgPop) * (exp(betai * logDroughtCount_future) - 1) * avgPop
  # SE
  #LCI
  attributable2$deathsAttributableLower <-
  (avgMonthlyDeaths/avgPop) * (exp((betai - sei * 1.96) *  logDroughtCount_future) - 1) * avgPop
  #UCI
  attributable2$deathsAttributableUpper <-
  (avgMonthlyDeaths/avgPop) * (exp((betai + sei * 1.96) * logDroughtCount_future) - 1) * avgPop
    
  detach(attributable2)
  head(attributable2)
    
    
  # now summarise by year
  summaryAttributable <- sqldf(
  'select year, sum(deathsAttributable) as deathsAttributable
  from attributable2
  group by year
  order by year
  ', drv = "SQLite")
  summaryAttributable
  # plot the estimated deaths
  ## with(summaryAttributable,
  ## plot(dthyy, deathsAttributable/deaths, type = 'l')
  ## )
  ## par(new=T)
  ## with(summaryAttributable,
  ## plot(dthyy, logDroughtCount, type = 'l',col = 'blue')
  ## )
  ## par(new=T)
  ## with(summaryAttributable,
  ## plot(dthyy, deaths, type = 'b',col = 'darkblue', pch=16)
  ## )
  # calcualte estimate
    
  estOut <- sqldf(
  'select 
  sum(deathsAttributable) as deathsAttributable,
  sum(deathsAttributableLower) as deathsAttributableLower,
  sum(deathsAttributableUpper) as deathsAttributableUpper
  from attributable2
  ', drv = "SQLite")
    
  # The predicted number of rural male suicides aged 30-49 per annum associated with droughts over our study period was 4.01 (95%CI 2.14 to 6.05)
  estOut$deathsAttributable
  length(names(table(attributable2$year)))
  estOut$deathsAttributable / 92
  estOut$deathsAttributableLower / 92
  estOut$deathsAttributableUpper / 92
    
  # DRY scenario given all years 2009-2100 droughts
  ## > estOut$deathsAttributable
  ## [1] 269.3154
  ## > length(names(table(attributable2$year)))
  ## [1] 92
  ## > estOut$deathsAttributable / 92
  ## [1] 2.927341
  ## > estOut$deathsAttributableLower / 92
  ## [1] 1.542382
  ## > estOut$deathsAttributableUpper / 92
  ## [1] 4.465849
   
  
#+end_src

*** COMMENT estimates_per_drougth_year
#+name:estimates_per_drougth_year
#+begin_src R :session *shell* :tangle no :exports none :eval no
  #### name:estimates_per_drougth_year ####



    
  # This is not as good a representation as by drought year.
  # to calculate number of drought years get average of the number of drought years by Rural Regions
  # DROUGHT MONTHS DEFINED AS ANY MONTH WHERE THE DROUGHT INDEX IS
  # GREATER THAN OR EQUAL TO 5.
  droughtyears <- sqldf("select sd_group, sum(droughtmonth)/12 as droughtyears
  from
  (
  select sd_group, agegp, sex, time, avcount,
  case when avcount >= 5 then 1 else 0 end as droughtmonth
  from data
  where agegp = '10_19' and sex = 1
  order by sd_group
  ) t1
  group by sd_group
  ")
    
  # sanity check
  qc <- sqldf("select sd_group, agegp, sex, time, avcount,
        case when avcount >= 5 then 1 else 0 end as droughtmonth
  from data
  where agegp = '10_19' and sex = 1 and sd_group = 'Central West'
  order by sd_group
  ")
    
  png(file.path(rootdir,'CentralWestDrought19702007.png'),res=200,width = 2100, height = 1000)
  with(qc, plot(time, avcount, type = 'l', axes=F))
  with(qc, points(time, avcount, pch = 16, cex=.5))
  box();axis(2);
  axis(1,at=as.Date(paste(1970:2007,'-01-01',sep='')),labels=NA)
  axis(1,at=as.Date(paste(seq(1970, 2007,5),'-01-01',sep='')),labels=seq(1970, 2007,5))
       segments(as.Date(paste(1970:2007,'-01-01',sep='')),0,as.Date(paste(1970:2007,'-01-01',sep='')),12,lty=3)
  segments(min(qc$time),5,max(qc$time),5)
    
  # calculate beginning and end of drougths
  indicator <- cbind(qc$avcount,c(NA,qc[1:(nrow(qc)-1),'avcount']))
  drtstrt <- which(indicator[,1] >=5 & indicator[,2] <5)
  #points(qc$time[drtstrt],qc$avcount[drtstrt], col = 'red')
  drtend <- which(indicator[,1] <5 & indicator[,2] >=5)
  #points(qc$time[drtend-1],rep(5,length(drtend)))
    
     cbind(rep(c(min(qc$time)-(5*365),max(qc$time)+(5*365),max(qc$time)+(5*365),min(qc$time)-(5*365)),3),
  c(drtstrt,drtstrt,drtend-1,drtend-1))
    #polygon(c(min(qc$time)-(5*365),max(qc$time)+(5*365),max(qc$time)+(5*365),min(qc$time)-(5*365)),c(4,4,14,14),col='grey')
  for(i in 1:9){
  polygon(c(qc$time[drtstrt[i]],qc$time[drtend[i]-1],qc$time[drtend[i]-1],qc$time[drtstrt[i]]),
  c(5,5,14,14), col='grey')
  }
  with(qc, lines(time, avcount))
  with(qc, points(time, avcount, pch = 16, cex=.5))
  #points(qc$time[drtstrt],qc$avcount[drtstrt], col = 'red')
    legend('topleft',legend=c('droughtIndex','droughtDeclared'),fill=c(NA,'grey'),border=c(NA,'black'),lty=c(1,NA))
  dev.off()
    
  # check against http://www.dpi.nsw.gov.au/agriculture/emergency/drought/planning/climate/advance-retreat
    
    
  # THIS NEXT ONE CALCULATES THE NUMBER PER DROUGHT YEAR AND COMES UP WITH 17
  # INTERESTING ATTEMPT THAT I MIGHT COME BACK TO
  # BUT FOR NOW WE ARE NOT HAPPY TO INCORPORATE THE ARBITRARY DROUGHT THRESHOLDS IN OUR PREDICTION
    
    
  droughtyearsRural <- droughtyears[!droughtyears$sd_group %in% c('Sydney','Hunter','Illawarra'),]
  #                 sd_group droughtyears
  # 1           Central West            3
  # 4        Mid-North Coast            3
  # 5                 Murray            2
  # 6           Murrumbidgee            3
  # 7  North and Far Western            2
  # 8               Northern            2
  # 9         Richmond-Tweed            5
  # 10         South Eastern            4
  mean(droughtyearsRural$droughtyears)
  # 3
  # so 3 out of 38
  (3/38)*100 # 7.9%
    
  table(attributable$sd_group)
  # set drought index to 0 if <5
  attributable$logDroughtCountDeclared <- ifelse(attributable$logDroughtCount >= log1p(5), attributable$logDroughtCount, 0)
  attach(attributable)
  # TODO this is clobbering the previous calculation, it would be best to keep that and make new names?
  attributable$deathsAttributable <-
  (avgMonthlyDeaths/avgPop) * (exp(betai * logDroughtCountDeclared) - 1) * pop
  # SE
  #LCI
  attributable$deathsAttributableLower <-
  (avgMonthlyDeaths/avgPop) * (exp((betai - sei * 1.96) *  logDroughtCountDeclared) - 1) * pop
  #UCI
  attributable$deathsAttributableUpper <-
  (avgMonthlyDeaths/avgPop) * (exp((betai + sei * 1.96) * logDroughtCountDeclared) - 1) * pop
    
  detach(attributable)
  head(subset(attributable, logDroughtCountDeclared != 0))
    
    
  # now summarise by year
  summaryAttributable <- sqldf(
  'select dthyy, sum(deathsAttributable) as deathsAttributable,
  sum(deaths) as deaths,
  sum(pop) as pop,
  round(avg(logDroughtCountDeclared),1) as logDroughtCountDeclared
    
  from attributable
  group by dthyy
  order by dthyy
  ')
  summaryAttributable
  # plot the estimated deaths
  with(summaryAttributable,
  plot(dthyy, deathsAttributable, type = 'b', pch = 16)
  )
  par(new=T)
  with(summaryAttributable,
  plot(dthyy, logDroughtCountDeclared, type = 'l',col = 'blue')
  )
  #   par(new=T)
  #   with(summaryAttributable,
  #    plot(dthyy, deaths, type = 'b',col = 'darkblue', pch=16)
  #    )
  # calcualte estimate
    
  estOut <- sqldf(
  'select sum(deaths) as deaths,
  sum(deathsAttributable) as deathsAttributable,
  sum(deathsAttributableLower) as deathsAttributableLower,
  sum(deathsAttributableUpper) as deathsAttributableUpper
  from attributable
  ')
    
  # The predicted number of rural male suicides aged 30-49 per drought year over our study period was 17.73 (95%CI 9.26 to 27.29)
  estOut$deathsAttributable
  # [1] 53.19648
    
  estOut$deathsAttributable / 3
  # 17.73216
  estOut$deathsAttributableLower / 3
  # 9.260883
  estOut$deathsAttributableUpper / 3
  # 27.28826
    
#+end_src
